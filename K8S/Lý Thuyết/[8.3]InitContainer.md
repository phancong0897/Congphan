# Kubernetes Structural Patterns: Init Containers

<h3 align="center"><img src="../Images/51.png"></h3>

- Structural Patterns bao gồm:

    - Init Containers.
    
    - Sidecar.
    
    - Adapter.
    
    - Ambassador.

### Init Containers

Init Containers là những Container được thực thi ở quá trình khởi tạo Pod (Initialization Stage), các Container này được thực thi trước khi các Container chứa ứng dụng được tạo. Trong một Pod ta có thể khai báo một hay nhiều Init Containers, và chúng sẽ được thực thi theo thứ tự ta khai báo.

Init Containers được sử dụng để khởi tạo tài nguyên hoặc cấu hình những thứ cần thiết cho Container chứa ứng dụng. Tưởng tượng giống như trong ngôn ngữ JAVA và PHP, khi ta viết một Class và cần cấu hình những giá trị cần thiết cho Class đó khi nó được tạo thì ta sẽ khai báo một Constructors cho nó. Init Containers cũng tượng tự như vậy nhưng sử dụng cho Pod.

<h3 align="center"><img src="../Images/52.png"></h3>

Từ hình trên thì một Pod được tách ra thành hai phần là: Init Containers và Application Containers. Tất cả Init Containers sẽ được chạy theo thứ tự và khi tất cả Init Containers được thực thi xong thì Application Containers mới được chạy.

` Nếu có nhiều Application Containers thì tất cả Application Containers sẽ được thực thi song song với nhau chứ không phải theo thứ tự như Init Containers. `

- Khác biệt so với Container thông thường
    
    - Init container hỗ trợ tất cả các trường và tính năng của app container bao gồm giới hạn tài nguyên, volume và các thiết lập bảo mật. Tuy nhiên, các yêu cầu và giới hạn tài nguyên cho init container được quản lý hơi khác (sẽ mô tả trong phần Tài nguyên)

    - Ngoài ra, init container không hỗ trợ lifecycle, readinessProbe, readinessProbe hay startupProbe bởi vì chúng phải chạy cho đến khi hoàn thành trước khi pod có thể ở trạng thái ready.

    - Nếu ta chỉ định nhiều init container cho 1 pod, kubelet sẽ chạy từng init container theo thứ tự. Mỗi init container phải thành công trước khi init container tiếp theo được chạy. Khi tất cả init container đều hoàn thành, kubelet sẽ khởi chạy các app container cho pod như bình thường.

- Sử dụng init container
    
    - Bởi vì init container có các image tách biệt với các app container nên chúng có vài lợi thế cho các mã khởi động (startup code):

        - Init container có thể chứa các tiện ích (utilities) hoặc mã tùy biến (custom code) để cài đặt. Ví dụ: ta không cần phải tạo 1 image FROM 1 image khác chỉ để sử dụng các tool như sed, awk, python hay dig trong quá trình cài đặt
    
        - Vai trò của người xây dựng (build) image và người triển khai (deployer) ứng dụng có thể hoạt động độc lập mà không cần phải cùng nhau xây dựng 1 image ứng dụng duy nhất.
    
        - Init container có thể chạy với 1 góc nhìn khác đối với hệ thống tập tin (filesystem) so với app container trong cùng 1 pod. Kết quả là chúng có thể được cấp quyền truy cập vào các Secret (lưu trữ thông tin nhạy cảm như password, token, key …) mà app container không thể.
        
        - Bởi vì init container phải chạy cho đến khi hoàn thành trước khi bất kỳ app container nào có thể chạy nên init container cung cấp 1 cơ chế để chặn hoặc trì hoãn việc khởi động app container cho đến khi các điều kiện tiên quyết được thỏa mãn. Khi các điều kiện này được thỏa mãn, tất cả các app container trong pod có thể khởi động song song.
        
        - Init container có thể chạy các tiện ích hoặc mã tùy biến một cách an toàn nếu so với chạy trong app container sẽ kém an toàn hơn. Bằng cách tách riêng các công cụ không cần thiết, ta có thể giới hạn các cuộc tấn công bề mặt lên image của ứng dụng container.

#### Sử dụng init container trong thực tế

- Ví dụ này định nghĩa một Pod đơn giản có 2 init container. Container đầu tiên chờ đợi myservice và container thứ hai chờ đợi mydb. Khi cả hai init container hoàn tất (nghĩa là cả myservice và mydb đã sẵn sàng phục vụ), Pod sẽ chạy app container từ phần spec của nó.

```

apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox:1.28
    command: ['sh', '-c', 'echo The app is running! && sleep 3600']
  initContainers:
  - name: init-myservice
    image: busybox:1.28
    command: ['sh', '-c', "until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done"]
  - name: init-mydb
    image: busybox:1.28
    command: ['sh', '-c', "until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done"]

```

- Ta có thể khởi tạo Pod trên bằng lệnh:  ` kubectl apply -f myapp.yaml `

- Sau đó kiểm tra trạng thái bằng lệnh: ` kubectl get -f myapp.yaml `

<h3 align="center"><img src="../Images/53.png"></h3>

- Tại thời điểm này, các init container sẽ chờ đợi các Service có tên là mydb và myservice.

    - Bên dưới là ví dụ cấu hình cho các service đó:

    ```
    ---
    apiVersion: v1
    kind: Service
    metadata:
      name: myservice
    spec:
      ports:
      - protocol: TCP
        port: 80
        targetPort: 9376
    ---
    apiVersion: v1
    kind: Service
    metadata:
      name: mydb
    spec:
      ports:
      - protocol: TCP
        port: 80
        targetPort: 9377

    ```

- Để tạo ra 2 service myservice và mydb theo đặc tả trên, ta chạy lệnh sau: ` kubectl apply -f services.yaml `

- Sau đó, ta sẽ thấy các init container đó đã hoàn thành nhiệm vụ và Pod myapp-pod chuyển sang trạng thái Running:   ` kubectl get -f myapp.yaml `

<h3 align="center"><img src="../Images/54.png"></h3>

